# Feature Specification: バックエンドエラーハンドリング実装

**Feature Branch**: `005-`
**Created**: 2025-11-13
**Status**: Draft
**Input**: User description: "バックエンドエラーハンドリング実装"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - システムエラー発生時の明確なフィードバック (Priority: P1)

アプリケーション利用中にサーバーエラーが発生した場合、ユーザーは何が問題なのかを理解でき、適切な対処方法（再試行、サポート連絡等）を知ることができる。

**Why this priority**: ユーザー体験の基盤となる機能。エラーメッセージが不明瞭だと、ユーザーは問題解決できず離脱する。すべてのAPI利用で必要となるため最優先。

**Independent Test**: 任意のAPIエンドポイントでエラーを発生させ、レスポンスが統一されたJSON形式で返ることを確認。ユーザーに表示されるエラーメッセージが分かりやすいことを検証。

**Acceptance Scenarios**:

1. **Given** ユーザーがログインフォームに無効なメールアドレスを入力、**When** 送信ボタンをクリック、**Then** 「メールアドレスの形式が正しくありません」という明確なエラーメッセージが表示される
2. **Given** ユーザーがワークアウト登録中にデータベース接続が切断、**When** 登録ボタンをクリック、**Then** 「現在サーバーに接続できません。しばらくしてから再試行してください」というメッセージが表示される
3. **Given** ユーザーが権限のないデータにアクセスを試行、**When** APIリクエストを送信、**Then** 「このリソースへのアクセス権限がありません」というメッセージが表示され、ログインページへの案内がある
4. **Given** ユーザーがStrava連携中にネットワークエラーが発生、**When** 連携ボタンをクリック、**Then** 「Stravaとの通信に失敗しました。インターネット接続を確認してください」と表示される
5. **Given** 開発環境でエラーが発生、**When** APIレスポンスを確認、**Then** スタックトレースや詳細なエラー情報が含まれる（デバッグ用）
6. **Given** 本番環境でエラーが発生、**When** APIレスポンスを確認、**Then** スタックトレースは含まれず、セキュアなエラーメッセージのみ返される

---

### User Story 2 - エラーの追跡とデバッグの容易性 (Priority: P2)

開発者やシステム管理者が、本番環境で発生したエラーを迅速に特定し、原因を調査できる。ユーザーからの問い合わせに対して、具体的なエラー内容を参照して対応できる。

**Why this priority**: システムの保守運用に不可欠。エラーログがないと、問題の原因特定に膨大な時間がかかり、ユーザーサポートの品質が低下する。P1の基盤機能の次に重要。

**Independent Test**: エラーを発生させ、構造化されたログが記録されること、リクエストIDでログを追跡できることを確認。ログファイルにタイムスタンプ、エラー種別、スタックトレース等が含まれることを検証。

**Acceptance Scenarios**:

1. **Given** APIエラーが発生、**When** ログファイルを確認、**Then** エラーの種類（ValidationError、DatabaseError等）、発生時刻、エンドポイント、ユーザーID、スタックトレースが記録されている
2. **Given** ユーザーから「エラーが出た」と問い合わせ、**When** ユーザーに表示されたリクエストIDを取得、**Then** そのIDでログを検索し、該当エラーの詳細情報が取得できる
3. **Given** 複数のエラーが同時発生、**When** ログを確認、**Then** 各エラーに一意のリクエストIDが付与され、個別に追跡できる
4. **Given** データベース接続エラーが発生、**When** ログを確認、**Then** エラーレベルが「error」でログに記録され、接続先、エラーコード、再試行情報が含まれる
5. **Given** 警告レベルのイベント（例：レート制限警告）が発生、**When** ログを確認、**Then** エラーレベルが「warn」で記録され、本番環境でも確認できる

---

### User Story 3 - API乱用からの保護 (Priority: P3)

悪意のあるユーザーや誤った実装により、短時間に大量のリクエストが送信された場合、システムを保護しながら、正当なユーザーには適切なフィードバックを提供する。

**Why this priority**: セキュリティとシステム安定性に関わるが、P1, P2のエラーハンドリング基盤がなくても独立して実装可能。DoS攻撃やAPI乱用のリスクを軽減する。

**Independent Test**: 特定のエンドポイントに短時間で大量のリクエストを送信し、レート制限が動作してHTTP 429が返されることを確認。制限解除後は正常にリクエストが処理されることを検証。

**Acceptance Scenarios**:

1. **Given** ユーザーが15分間に100回以上のログイン試行、**When** 101回目のリクエストを送信、**Then** HTTP 429（Too Many Requests）が返され、「リクエスト上限に達しました。15分後に再試行してください」というメッセージが表示される
2. **Given** レート制限に達したユーザー、**When** レスポンスヘッダーを確認、**Then** `Retry-After`ヘッダーに制限解除までの秒数が含まれる
3. **Given** 正当なユーザーが通常の頻度でAPIを利用、**When** リクエストを送信、**Then** レート制限に引っかからず、正常に処理される
4. **Given** 悪意のあるボットが複数エンドポイントを攻撃、**When** 各エンドポイントにレート制限を設定、**Then** すべてのエンドポイントで個別に制限が適用され、システム全体が保護される

---

### User Story 4 - データベース障害時のグレースフルな応答 (Priority: P2)

データベース接続が失敗またはタイムアウトした場合、システムは適切にエラーを処理し、ユーザーに分かりやすいメッセージを提供する。サーバー起動時にデータベース接続を確認し、接続できない場合は起動を中止する。

**Why this priority**: インフラ障害時のユーザー体験を守る。データベースエラーが適切に処理されないと、アプリ全体がクラッシュする可能性がある。P1の一部として扱うべきだが、独立して実装可能なためP2。

**Independent Test**: データベースを停止した状態でサーバー起動を試行し、起動が失敗することを確認。データベース稼働中にクエリエラーを発生させ、適切なエラーレスポンスが返されることを検証。

**Acceptance Scenarios**:

1. **Given** データベースが停止している状態、**When** サーバーを起動、**Then** 起動が失敗し、「データベースに接続できません」というエラーログが出力される
2. **Given** サーバー稼働中にデータベース接続が切断、**When** ユーザーがワークアウトデータを取得、**Then** HTTP 503（Service Unavailable）が返され、「現在サービスが利用できません。しばらくしてから再試行してください」と表示される
3. **Given** データベースクエリがタイムアウト、**When** ユーザーが大量データを要求、**Then** HTTP 504（Gateway Timeout）が返され、「処理に時間がかかっています。条件を絞って再試行してください」と表示される
4. **Given** Sequelizeの一意制約違反が発生、**When** 重複したメールアドレスで登録試行、**Then** HTTP 409（Conflict）が返され、「このメールアドレスは既に使用されています」と表示される

---

### Edge Cases

- **大量の同時エラー発生時**: 複数のユーザーで同時にエラーが発生した場合、ログシステムが過負荷にならず、すべてのエラーが記録されるか？
- **ログファイルの肥大化**: エラーログが無制限に増加し、ディスク容量を圧迫しないか？ログローテーションは実装されているか？
- **ネットワーク分断**: フロントエンドからバックエンドへの接続が完全に失敗した場合、ユーザーは適切なオフラインメッセージを受け取るか？
- **循環エラー**: エラーハンドラー自体がエラーを発生させた場合（例：ログ記録処理の失敗）、無限ループに陥らないか？
- **国際化**: エラーメッセージは日本語と英語の両方で提供されるか？ユーザーの言語設定に応じて切り替わるか？
- **CORS事前チェック失敗**: OPTIONS リクエストがCORS設定ミスで失敗した場合、適切なエラーメッセージが返されるか？
- **巨大なリクエストボディ**: 制限を超えるサイズのリクエストが送信された場合、適切に拒否され、413エラーが返されるか？
- **不正なJSON形式**: リクエストボディが不正なJSON形式の場合、400エラーとともに「リクエストの形式が不正です」というメッセージが返されるか？

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは、すべてのAPIエンドポイントで統一されたエラーレスポンス形式を返さなければならない（JSON形式: `{status: number, code: string, message: string, details?: any, requestId: string, timestamp: string}`）
- **FR-002**: システムは、エラーの種類に応じて適切なHTTPステータスコードを返さなければならない（400: Validation, 401: Unauthorized, 403: Forbidden, 404: Not Found, 409: Conflict, 429: Rate Limit, 500: Server Error, 503: Service Unavailable）
- **FR-003**: システムは、すべてのエラーに一意のリクエストIDを付与し、エラーレスポンスとログの両方に含めなければならない
- **FR-004**: システムは、本番環境（NODE_ENV=production）ではスタックトレースをクライアントに送信してはならず、開発環境でのみ詳細情報を提供しなければならない
- **FR-005**: システムは、構造化ログフォーマット（JSON形式）でエラー情報を記録しなければならない（最低限以下を含む: timestamp, level, requestId, userId, endpoint, method, statusCode, errorType, message, stack）
- **FR-006**: システムは、エラーログをログレベル別に記録しなければならない（error: システムエラー、warn: 警告、info: 情報、debug: デバッグ情報）
- **FR-007**: システムは、Sequelize ORM特有のエラー（SequelizeValidationError, SequelizeDatabaseError, SequelizeUniqueConstraintError等）を検出し、適切なHTTPステータスコードとユーザーフレンドリーなメッセージに変換しなければならない
- **FR-008**: システムは、JWT認証エラー（トークン期限切れ、無効なトークン、トークン不在等）を検出し、401ステータスと適切なメッセージを返さなければならない
- **FR-009**: システムは、サーバー起動時にデータベース接続を確認し、接続できない場合は起動を中止しなければならない
- **FR-010**: システムは、API エンドポイントごとにレート制限を設定し、制限を超えたリクエストには HTTP 429 を返さなければならない（デフォルト: 100リクエスト/15分）
- **FR-011**: システムは、レート制限に達したリクエストに対して、`Retry-After` ヘッダーで制限解除までの時間を提供しなければならない
- **FR-012**: システムは、入力バリデーションエラーを検出し、HTTP 400 とともに、エラー箇所と理由を明示した詳細情報を返さなければならない
- **FR-013**: システムは、予期しないエラー（未処理の例外）をキャッチし、HTTP 500 とともに汎用的なエラーメッセージを返さなければならない（「サーバーでエラーが発生しました。しばらくしてから再試行してください」）
- **FR-014**: システムは、CORSエラーを適切に処理し、許可されていないオリジンからのリクエストには 403 エラーを返さなければならない
- **FR-015**: システムは、ログファイルをサイズまたは日付でローテーションし、古いログを自動的にアーカイブまたは削除しなければならない（例: 1日ごとまたは10MBごと、30日以上古いログは削除）

### Key Entities *(include if feature involves data)*

- **ErrorResponse**: APIエラーレスポンスの標準形式
  - `status`: HTTPステータスコード（400, 401, 500等）
  - `code`: エラーの種類を示すコード（VALIDATION_ERROR, UNAUTHORIZED, DATABASE_ERROR等）
  - `message`: ユーザーに表示する人間が読めるエラーメッセージ（日本語）
  - `details`: エラーの詳細情報（オプション、バリデーションエラーの場合はフィールド別エラー等）
  - `requestId`: リクエストを一意に識別するID（UUID形式）
  - `timestamp`: エラー発生時刻（ISO 8601形式）

- **StructuredLog**: 構造化ログエントリ
  - `timestamp`: ログ記録時刻（ISO 8601形式）
  - `level`: ログレベル（error, warn, info, debug）
  - `requestId`: リクエストID（ErrorResponseと同一）
  - `userId`: ユーザーID（認証済みの場合）
  - `endpoint`: APIエンドポイントパス（例: /api/workouts）
  - `method`: HTTPメソッド（GET, POST等）
  - `statusCode`: レスポンスステータスコード
  - `errorType`: エラーの種類（SequelizeValidationError, UnauthorizedError等）
  - `message`: エラーメッセージ
  - `stack`: スタックトレース（error レベルのみ）
  - `metadata`: 追加のコンテキスト情報（リクエストボディ、クエリパラメータ等）

- **RateLimitConfig**: レート制限設定
  - `endpoint`: 対象エンドポイントパターン（例: /api/auth/login）
  - `windowMs`: 時間枠（ミリ秒、例: 15分 = 900000ms）
  - `maxRequests`: 時間枠内の最大リクエスト数（例: 100）
  - `message`: レート制限到達時のメッセージ

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: すべてのAPIエンドポイント（認証、ワークアウト、Strava連携、インサイト等）で、同一のJSON構造のエラーレスポンスが返される（100%の一貫性）
- **SC-002**: 本番環境でエラーが発生した際、ユーザーには汎用的なメッセージのみが表示され、スタックトレースやシステム内部情報が露出しない（セキュリティ監査で0件の情報漏洩）
- **SC-003**: 開発者は、ユーザーから提供されたリクエストIDを使って、5分以内に該当エラーの詳細ログを取得し、原因を特定できる
- **SC-004**: エラーログには、問題解決に必要な情報（発生時刻、エンドポイント、ユーザーID、エラー種別、スタックトレース）が100%含まれている
- **SC-005**: ログイン試行などの機密性の高いエンドポイントで、レート制限が動作し、15分間に100回を超えるリクエストは拒否される（テストで100%の成功率）
- **SC-006**: データベース停止時にサーバー起動を試みた場合、100%の確率で起動が失敗し、明確なエラーメッセージがコンソールに出力される
- **SC-007**: 既存のすべてのAPIエンドポイントのテストスイートで、エラーケースのテストが追加され、90%以上のテストが成功する
- **SC-008**: ユーザーからの「エラーメッセージが分かりにくい」という問い合わせが、実装後3ヶ月で50%以上減少する
- **SC-009**: システム管理者が、週次で生成されるエラーレポートから、頻発するエラーパターンを特定し、予防的な改善を実施できる
- **SC-010**: ログファイルがディスク容量を圧迫せず、自動ローテーションにより常に30日以内のログのみが保持される
